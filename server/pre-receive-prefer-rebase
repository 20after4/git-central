#!/bin/sh

while read oldrev newrev refname ; do
	if expr "$oldrev" : '0*$' >/dev/null ; then
		exit 0
	fi

	# If the new ref is a merge, it'll have spaces in the parents log (ugly, yes)
	git log -n 1 --pretty=format:%p $newrev | grep " "
	if [ $? -ne 0 ] ; then
		exit 0
	fi

	# If they are introducing non-merge commits /and/ merge commits, it could
	# look like one of two ways. This way:
	#
	# * --- B --- * --- oldrev
	#        \             \
	#        new --- new --- newrev
	#
	# They basically had an un-shared local dev branch (probably by making a
	# merge) and instead should have done a rebase.
	#
	# But if it looks like:
	#
	# * --- B --- * --- oldrev
	#        \              \
	#        old --- new --- newrev
	#
	# Then they had a pre-shared branch that cannot be rebased and so they
	# were correct in doing a merge to tie "old" and "oldrev" together.

	# Find the original branch point (B)
	baserev=$(git merge-base $oldrev $newrev)

	# Before newrev is trying to be pushed, what was the old leg?
	base_to_old=$(git rev-list $baserev..$oldrev | wc -l)

	# We can now guess the new log by finding both legs old..new...
	base_to_new=$(git rev-list $baserev..$newrev | wc -l)
	# And then substract out the old leg
	new_leg=$(expr $base_to_new - $base_to_old)

	# See post-receive-email for an explanation of this--all new commits
	all_new=$(git rev-parse --not --branches | grep -v $(git rev-parse $refname) | git rev-list --stdin $oldrev..$newrev | wc -l)

	# If all of their new commits on on their new lew, they didn't have any shared, they should have rebased
	if [ $all_new -eq $new_leg ] ; then
		echo "----------------------------------------------------"
		echo
		echo "It looks like you should rebase"
		echo
		echo "----------------------------------------------------"
		exit 1
	fi
done

